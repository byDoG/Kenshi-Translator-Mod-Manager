import os
import json
import tkinter as tk

MODS_FILE = "mods_all.json"

# =============== MESSAGE POPUP ====================

def show_message(message, on_close=None):
    root = tk.Tk()
    root.overrideredirect(True)
    win_w, win_h = 500, 90
    screen_w = root.winfo_screenwidth()
    screen_h = root.winfo_screenheight()
    pos_x = (screen_w // 2) - (win_w // 2)
    pos_y = (screen_h // 2) - (win_h // 2)
    root.geometry(f"{win_w}x{win_h}+{pos_x}+{pos_y}")
    canvas = tk.Canvas(root, width=win_w, height=win_h, highlightthickness=0, bg="#222222")
    canvas.pack(fill="both", expand=True)
    border_color = "#FFFF00"
    border_width = 6
    canvas.create_line(0, 0, win_w, 0, fill=border_color, width=border_width)
    canvas.create_line(0, win_h, win_w, win_h, fill=border_color, width=border_width)
    canvas.create_text(win_w // 2, win_h // 2, text=message,
                       fill="white", font=("Arial", 20, "bold"))

    def close_and_callback():
        root.destroy()
        if on_close:
            on_close()

    root.after(2000, close_and_callback)  # окно закрывается через 2 сек
    root.mainloop()


# Приоритет главных групп
GROUPS_PRIORITY = [
    "S-Animation",
    "S-Graphical",
    "S-GUI",

    "S-Total Overhaul",
    "S-Buildings",

    "S-Gameplay",

    "S-Cheats",
    "S-Translation",
    "S-Unknown",
    "S-Disabled",
]

# Дочерние группы
SUBGROUPS = {
    "S-GUI": ["SS-Animation"],
    "S-Total Overhaul": ["SS-Research"],
    "S-Gameplay": ["SS-Characters", "SS-Races", "SS-Factions", "SS-Clothing/Armour", "SS-Items/Weapons"],
}

# Жёстко закреплённые глобальные патчи
GLOBAL_PATCHES = {
    "-KCF autogenerated patch-.mod",
    "Unofficial Patches for Kenshi.mod",
    "KenshiTranslator.mod"
}


def detect_main_group(mod):
    tags = (mod.get("tags") or "").lower()
    name = mod.get("name", "").lower()

    if "skeleton" in name or "animation" in tags:
        return "S-Animation"
    if "gui" in tags:
        return "S-GUI"
    if "graphical" in tags:
        return "S-Graphical"
    if "total overhaul" in tags:
        return "S-Total Overhaul"
    if "buildings" in tags:
        return "S-Buildings"
    if "cheats" in tags:
        return "S-Cheats"
    if "translation" in tags:
        return "S-Translation"
    if not tags.strip():
        return "S-Unknown"
    if not mod.get("enabled", True):
        return "S-Disabled"
    return "S-Gameplay"


def detect_subgroup(mod, main_group):
    tags = (mod.get("tags") or "").lower()
    if main_group == "S-GUI" and "animation" in tags:
        return "SS-Animation"
    if main_group == "S-Total Overhaul" and "research" in tags:
        return "SS-Research"
    if main_group == "S-Gameplay":
        if "characters" in tags:
            return "SS-Characters"
        if "races" in tags:
            return "SS-Races"
        if "factions" in tags:
            return "SS-Factions"
        if "clothing" in tags or "armour" in tags:
            return "SS-Clothing/Armour"
        if "items" in tags or "weapons" in tags:
            return "SS-Items/Weapons"
    return None


def phase1_grouping(mods):
    groups = {g: [] for g in GROUPS_PRIORITY}
    for mod in mods:
        if "name" not in mod or mod.get("dummy"):
            continue
        main_group = detect_main_group(mod)
        if main_group not in groups:
            main_group = "S-Unknown"
        groups[main_group].append(mod)
    return groups


def phase2_subgroups(groups):
    """Фаза 2 — перемещение модов в дочерние группы (без дублей)"""
    new_groups = {g: [] for g in GROUPS_PRIORITY}
    for main, subs in SUBGROUPS.items():
        if main not in new_groups:
            new_groups[main] = []
        for sub in subs:
            new_groups[sub] = []

    for main, mods in groups.items():
        for mod in mods:
            subgroup = detect_subgroup(mod, main)
            if subgroup and subgroup in new_groups:
                new_groups[subgroup].append(mod)   # перемещаем в SS
            else:
                new_groups[main].append(mod)       # иначе остаётся в S

    return new_groups


def phase3_dependencies(groups):
    """Фаза 3 — пересборка порядка с зависимостями (до 20 итераций)"""
    all_mods = {}
    for mods in groups.values():
        for mod in mods:
            all_mods[mod["name"].lower()] = mod

    total_changes = 0
    for _ in range(20):
        changed = False
        new_groups = {}
        for gname, mods in groups.items():
            ordered = []
            seen = set()

            def place(mod):
                if mod["name"].lower() in seen:
                    return
                for dep in mod.get("dependencies", []):
                    dep_mod = all_mods.get(dep.strip().lower())
                    if dep_mod:
                        place(dep_mod)
                ordered.append(mod)
                seen.add(mod["name"].lower())

            for mod in mods:
                place(mod)

            if [m["name"] for m in ordered] != [m["name"] for m in mods]:
                changed = True
            new_groups[gname] = ordered

        groups = new_groups
        if changed:
            total_changes += 1
        else:
            break

    if total_changes == 0:
        print("ℹ️ Dependencies already stable (0 changes)")
    else:
        print(f"ℹ️ Dependencies stabilized after {total_changes} iteration(s)")
    return groups


def phase35_global_patches(groups):
    global_section = []
    for gname in list(groups.keys()):
        remain = []
        for mod in groups[gname]:
            if mod["name"] in GLOBAL_PATCHES:
                global_section.append(mod)
            else:
                remain.append(mod)
        groups[gname] = remain
    groups["SSS-Patches Global"] = global_section
    return groups


def order_mods():
    if not os.path.exists(MODS_FILE):
        show_message("PRESS SCAN MOD :)")
        return 0

    with open(MODS_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    mods = data.get("mods", [])

    if not mods:
        show_message("PRESS SCAN MOD :)")
        return 0

    dummy = next((m for m in mods if m.get("name") == "__panel_dummy__"), None)

    groups = phase1_grouping(mods)
    groups = phase2_subgroups(groups)
    groups = phase3_dependencies(groups)
    groups = phase35_global_patches(groups)

    new_mods = []
    seen_names = set()

    if dummy:
        new_mods.append(dummy)

    for g in GROUPS_PRIORITY:
        if g in groups:
            new_mods.append({"marker": f"{g} : ------------------//"})
            for mod in groups[g]:
                if mod["name"] not in seen_names:
                    new_mods.append(mod)
                    seen_names.add(mod["name"])
            for sub in SUBGROUPS.get(g, []):
                if sub in groups:
                    new_mods.append({"marker": f"{sub} : ------------------//"})
                    for mod in groups[sub]:
                        if mod["name"] not in seen_names:
                            new_mods.append(mod)
                            seen_names.add(mod["name"])

    if "SSS-Patches Global" in groups and groups["SSS-Patches Global"]:
        new_mods.append({"marker": "SSS-Patches Global : ------------------//"})
        for mod in groups["SSS-Patches Global"]:
            if mod["name"] not in seen_names:
                new_mods.append(mod)
                seen_names.add(mod["name"])

    data["mods"] = new_mods

    with open(MODS_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

    return len(new_mods)


def main():
    return order_mods()


if __name__ == "__main__":
    count = main()
    print(f"✅ Sorted {count} entries")
