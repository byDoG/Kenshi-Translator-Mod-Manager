import os
import json
import tkinter as tk
import threading

MODS_FILE = "mods_all.json"
LANG_FILE = "lang.json"
SETTINGS_FILE = "settings.json"

# === безопасная загрузка языка ===
if os.path.exists(SETTINGS_FILE):
    with open(SETTINGS_FILE, "r", encoding="utf-8") as f:
        settings = json.load(f)
    lang_name = settings.get("language", "English")
else:
    lang_name = "English"

if os.path.exists(LANG_FILE):
    with open(LANG_FILE, "r", encoding="utf-8") as f:
        lang_data = json.load(f)
else:
    lang_data = {"English": {"messages": {}, "buttons": {}}}

LANG = lang_data.get(lang_name, lang_data.get("English", {}))


# === ВСПЛЫВАЮЩЕЕ ОКНО ===
def show_message(message, border_color="#FFFF00"):
    root = tk.Tk()
    root.overrideredirect(True)
    win_w, win_h = 500, 90
    screen_w = root.winfo_screenwidth()
    screen_h = root.winfo_screenheight()
    pos_x = (screen_w // 2) - (win_w // 2)
    pos_y = (screen_h // 2) - (win_h // 2)
    root.geometry(f"{win_w}x{win_h}+{pos_x}+{pos_y}")

    canvas = tk.Canvas(root, width=win_w, height=win_h,
                       highlightthickness=0, bg="#222222")
    canvas.pack(fill="both", expand=True)

    border_width = 6
    canvas.create_line(0, 0, win_w, 0, fill=border_color, width=border_width)
    canvas.create_line(0, win_h, win_w, win_h, fill=border_color, width=border_width)
    canvas.create_text(win_w // 2, win_h // 2, text=message,
                       fill="white", font=("Arial", 20, "bold"))

    root.after(2000, root.destroy)
    root.mainloop()


# === НАСТРОЙКИ ГРУПП ===
GROUPS_PRIORITY = [
    "S-Animation",
    "S-Graphical",
    "S-GUI",
    "S-Total Overhaul",
    "S-Buildings",
    "S-Gameplay",
    "S-Cheats",
    "S-Translation",
    "S-Unknown",
    "S-Disabled",
]

SUBGROUPS = {
    "S-GUI": ["SS-Animation"],
    "S-Total Overhaul": ["SS-Research"],
    "S-Gameplay": [
        "SS-Characters", "SS-Races", "SS-Factions",
        "SS-Clothing/Armour", "SS-Items/Weapons"
    ],
}

GLOBAL_PATCHES = {
    "-KCF autogenerated patch-.mod",
    "Unofficial Patches for Kenshi.mod",
    "KenshiTranslator.mod"
}


# === ФАЗЫ ===
def detect_main_group(mod):
    tags = (mod.get("tags") or "").lower()
    name = mod.get("name", "").lower()

    if "skeleton" in name or "animation" in tags:
        return "S-Animation"
    if "gui" in tags:
        return "S-GUI"
    if "graphical" in tags:
        return "S-Graphical"
    if "total overhaul" in tags:
        return "S-Total Overhaul"
    if "buildings" in tags:
        return "S-Buildings"
    if "cheats" in tags:
        return "S-Cheats"
    if "translation" in tags:
        return "S-Translation"
    if not tags.strip():
        return "S-Unknown"
    if not mod.get("enabled", True):
        return "S-Disabled"
    return "S-Gameplay"


def detect_subgroup(mod, main_group):
    tags = (mod.get("tags") or "").lower()
    if main_group == "S-GUI" and "animation" in tags:
        return "SS-Animation"
    if main_group == "S-Total Overhaul" and "research" in tags:
        return "SS-Research"
    if main_group == "S-Gameplay":
        if "characters" in tags:
            return "SS-Characters"
        if "races" in tags:
            return "SS-Races"
        if "factions" in tags:
            return "SS-Factions"
        if "clothing" in tags or "armour" in tags:
            return "SS-Clothing/Armour"
        if "items" in tags or "weapons" in tags:
            return "SS-Items/Weapons"
    return None


def phase1_grouping(mods):
    groups = {g: [] for g in GROUPS_PRIORITY}
    for mod in mods:
        if "name" not in mod or mod.get("dummy"):
            continue
        main_group = detect_main_group(mod)
        if main_group not in groups:
            main_group = "S-Unknown"
        groups[main_group].append(mod)
    return groups


def phase2_subgroups(groups):
    new_groups = {g: [] for g in GROUPS_PRIORITY}
    for main, subs in SUBGROUPS.items():
        if main not in new_groups:
            new_groups[main] = []
        for sub in subs:
            new_groups[sub] = []

    for main, mods in groups.items():
        for mod in mods:
            subgroup = detect_subgroup(mod, main)
            if subgroup and subgroup in new_groups:
                new_groups[subgroup].append(mod)
            else:
                new_groups[main].append(mod)
    return new_groups


def phase3_dependencies(groups):
    all_mods = {}
    for mods in groups.values():
        for mod in mods:
            all_mods[mod["name"].lower()] = mod

    for _ in range(20):
        changed = False
        new_groups = {}
        for gname, mods in groups.items():
            ordered = []
            seen = set()

            def place(mod, stack=None):
                if stack is None:
                    stack = set()
                mod_name = mod["name"].lower()

                if mod_name in seen:
                    return
                if mod_name in stack:
                    return  # защита от рекурсии

                stack.add(mod_name)
                for dep in mod.get("dependencies", []):
                    dep_mod = all_mods.get(dep.strip().lower())
                    if dep_mod and dep_mod.get("enabled", True):
                        place(dep_mod, set(stack))
                stack.remove(mod_name)

                seen.add(mod_name)
                ordered.append(mod)

            for mod in mods:
                if not mod.get("enabled", True):
                    ordered.append(mod)
                else:
                    place(mod)

            if [m["name"] for m in ordered] != [m["name"] for m in mods]:
                changed = True
            new_groups[gname] = ordered

        groups = new_groups
        if not changed:
            break
    return groups


def phase35_global_patches(groups):
    global_section = []
    for gname in list(groups.keys()):
        remain = []
        for mod in groups[gname]:
            if mod["name"] in GLOBAL_PATCHES:
                global_section.append(mod)
            else:
                remain.append(mod)
        groups[gname] = remain
    groups["SSS-Patches Global"] = global_section
    return groups


# === ОСНОВНАЯ ЛОГИКА ===
def order_mods():
    if not os.path.exists(MODS_FILE):
        show_message(LANG.get("messages", {}).get("3", ""), border_color="#FFD700")
        return 0

    with open(MODS_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    mods = data.get("mods", [])

    if not mods:
        show_message(LANG.get("messages", {}).get("3", ""), border_color="#FFD700")
        return 0

    dummy = next((m for m in mods if m.get("name") == "__panel_dummy__"), None)

    groups = phase1_grouping(mods)
    groups = phase2_subgroups(groups)
    groups = phase3_dependencies(groups)
    groups = phase35_global_patches(groups)

    new_mods = []
    seen_names = set()

    if dummy:
        new_mods.append(dummy)

    for g in GROUPS_PRIORITY:
        if g in groups:
            new_mods.append({"marker": f"{g} : ------------------//"})
            for mod in groups[g]:
                if mod["name"] not in seen_names:
                    new_mods.append(mod)
                    seen_names.add(mod["name"])
            for sub in SUBGROUPS.get(g, []):
                if sub in groups:
                    new_mods.append({"marker": f"{sub} : ------------------//"})
                    for mod in groups[sub]:
                        if mod["name"] not in seen_names:
                            new_mods.append(mod)
                            seen_names.add(mod["name"])

    if "SSS-Patches Global" in groups and groups["SSS-Patches Global"]:
        new_mods.append({"marker": "SSS-Patches Global : ------------------//"})
        for mod in groups["SSS-Patches Global"]:
            if mod["name"] not in seen_names:
                new_mods.append(mod)
                seen_names.add(mod["name"])

    data["mods"] = new_mods

    with open(MODS_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

    # считаем только включённые моды
    active_count = sum(
        1 for m in new_mods if "name" in m and m.get("enabled", True) and m.get("name") != "__panel_dummy__"
    )
    return active_count


# === ВХОД ===
def main():
    count = order_mods()
    if count > 0:
        threading.Thread(
            target=lambda: show_message(
                LANG.get("messages", {}).get("40", "").format(count=count),
                border_color="#00FF00"
            )
        ).start()
        print(f"\033[92m{LANG.get('messages', {}).get('40', '').format(count=count)}\033[0m")
    return count


if __name__ == "__main__":
    main()
